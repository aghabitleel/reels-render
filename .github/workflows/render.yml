name: Render Reel

on:
  repository_dispatch:
    types: [render_reel]

permissions:
  contents: write

jobs:
  render:
    runs-on: ubuntu-latest
    env:
      LC_ALL: C

    steps:
      - name: Set up FFmpeg
        uses: FedericoCarboni/setup-ffmpeg@v2
        with:
          version: latest

      - name: Install jq and curl
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Capture payload
        run: |
          set -euo pipefail
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          cat payload.json

      - name: Read params
        run: |
          set -euo pipefail

          AUDIO_URL=$(jq -r '.audio_url' payload.json)
          OUT_NAME=$(jq -r '.out_name // "reel.mp4"' payload.json)
          WIDTH=$(jq -r '.width // 1080' payload.json)
          HEIGHT=$(jq -r '.height // 1920' payload.json)
          FPS=$(jq -r '.fps // 30' payload.json)
          CHUNK_SEC=$(jq -r '.chunk_sec // 4' payload.json)
          MAX_CLIPS=$(jq -r '.max_clips // 100' payload.json)
          LAYOUT_TYPE=$(jq -r '.layout_config.type // "single"' payload.json)

          jq -r '
            if (.script_lines | type=="array") then .script_lines|join("\n")
            elif (.script_text | type=="string") then .script_text
            else "" end
          ' payload.json > script.txt

          echo "AUDIO_URL=$AUDIO_URL" >> $GITHUB_ENV
          echo "OUT_NAME=$OUT_NAME" >> $GITHUB_ENV
          echo "WIDTH=$WIDTH" >> $GITHUB_ENV
          echo "HEIGHT=$HEIGHT" >> $GITHUB_ENV
          echo "FPS=$FPS" >> $GITHUB_ENV
          echo "CHUNK_SEC=$CHUNK_SEC" >> $GITHUB_ENV
          echo "MAX_CLIPS=$MAX_CLIPS" >> $GITHUB_ENV
          echo "LAYOUT_TYPE=$LAYOUT_TYPE" >> $GITHUB_ENV

      - name: Download audio
        run: |
          set -euo pipefail
          curl -L "$AUDIO_URL" -o audio.bin
          ffmpeg -y -i audio.bin -c:a aac -b:a 192k audio.m4a

      - name: Get audio duration
        run: |
          ffprobe -v error -show_entries format=duration -of csv=p=0 audio.m4a > audio_dur.txt

      - name: Download videos
        run: |
          set -euo pipefail

          if [ "$LAYOUT_TYPE" = "split_screen" ]; then
            i=0
            jq -r '.layout_config.top_videos[]' payload.json | while read -r u; do
              i=$((i+1)); [ $i -le $MAX_CLIPS ] || break
              curl -L "$u" -o "top_$i.mp4"
            done
            curl -L "$(jq -r '.layout_config.bottom_video' payload.json)" -o bottom.mp4
          else
            i=0
            jq -r '.video_urls[]' payload.json | while read -r u; do
              i=$((i+1)); [ $i -le $MAX_CLIPS ] || break
              curl -L "$u" -o "in_$i.mp4"
            done
          fi

      - name: Normalize videos
        run: |
          set -euo pipefail

          if [ "$LAYOUT_TYPE" = "split_screen" ]; then
            for f in top_*.mp4; do
              ffmpeg -y -i "$f" \
                -vf "scale=$WIDTH:$((HEIGHT/2)):force_original_aspect_ratio=increase,crop=$WIDTH:$((HEIGHT/2))" \
                -an "norm_$f"
            done
            ffmpeg -y -i bottom.mp4 \
              -vf "scale=$WIDTH:$((HEIGHT/2)):force_original_aspect_ratio=increase,crop=$WIDTH:$((HEIGHT/2))" \
              -an norm_bottom.mp4
          else
            for f in in_*.mp4; do
              ffmpeg -y -i "$f" \
                -vf "scale=$WIDTH:$HEIGHT:force_original_aspect_ratio=increase,crop=$WIDTH:$HEIGHT" \
                -an "norm_$f"
            done
          fi

      - name: Create chunks
        run: |
          set -euo pipefail

          TARGET=$(cat audio_dur.txt)
          CHUNK="$CHUNK_SEC"
          NEED=$(awk -v t="$TARGET" -v c="$CHUNK" 'BEGIN{print int(t/c+0.99)}')

          rm -f chunks.txt

          if [ "$LAYOUT_TYPE" = "split_screen" ]; then
            TOPS=(norm_top_*.mp4)
            for ((i=0;i<NEED;i++)); do
              t="${TOPS[$((i%${#TOPS[@]}))]}"
              out=$(printf "chunk_%04d.mp4" "$i")
              ffmpeg -y -i "$t" -i norm_bottom.mp4 \
                -filter_complex "[0:v][1:v]vstack" \
                -t "$CHUNK" -an "$out"
              echo "file '$out'" >> chunks.txt
            done
          else
            FILES=(norm_in_*.mp4)
            for ((i=0;i<NEED;i++)); do
              f="${FILES[$((i%${#FILES[@]}))]}"
              out=$(printf "chunk_%04d.mp4" "$i")
              ffmpeg -y -i "$f" -t "$CHUNK" -an "$out"
              echo "file '$out'" >> chunks.txt
            done
          fi

      - name: Concat chunks
        run: |
          set -euo pipefail
          ffmpeg -y -f concat -safe 0 -i chunks.txt -c copy stack.mp4

      - name: Build TikTok / Reels ASS subtitles
        run: |
          set -euo pipefail

          [ -s script.txt ] || exit 0

          TOTAL_SEC=$(cat audio_dur.txt)
          TEXT=$(tr '\n' ' ' < script.txt | sed 's/  */ /g')
          mapfile -t WORDS < <(echo "$TEXT" | tr ' ' '\n')

          CAPTION_X=$((WIDTH / 2))
          CAPTION_Y=$((HEIGHT * 5 / 6))

          : > subs.ass
          printf '%s\n' \
            '[Script Info]' \
            "PlayResX: ${WIDTH}" \
            "PlayResY: ${HEIGHT}" \
            'ScaledBorderAndShadow: yes' \
            '' \
            '[V4+ Styles]' \
            'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding' \
            'Style: Reels,DejaVu Sans Bold,54,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,1,0,0,0,100,100,0,0,1,6,2,2,60,60,40,1' \
            '' \
            '[Events]' \
            'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text' >> subs.ass

          START=0
          DUR_PER_WORD=$(awk -v t="$TOTAL_SEC" -v n="${#WORDS[@]}" 'BEGIN{print t/n}')

          for w in "${WORDS[@]}"; do
            END=$(awk -v s="$START" -v d="$DUR_PER_WORD" 'BEGIN{print s+d}')
            printf 'Dialogue: 0,0:%02d:%05.2f,0:%02d:%05.2f,Reels,,0,0,0,,{\\an5\\pos(%d,%d)\\fad(80,80)}%s\n' \
              0 "$START" 0 "$END" "$CAPTION_X" "$CAPTION_Y" "$w" >> subs.ass
            START=$END
          done

      - name: Burn subtitles and mux audio
        run: |
          set -euo pipefail
          ffmpeg -y -i stack.mp4 -i audio.m4a \
            -vf "subtitles=subs.ass" \
            -map 0:v:0 -map 1:a:0 \
            -shortest \
            -c:v libx264 -pix_fmt yuv420p -r "$FPS" \
            -c:a copy "$OUT_NAME"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: reel-output
          path: ${{ env.OUT_NAME }}
          retention-days: 90
