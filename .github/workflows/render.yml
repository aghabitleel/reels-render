name: Render Reel

on:
  repository_dispatch:
    types: [render_reel]

permissions:
  contents: write

jobs:
  render:
    runs-on: ubuntu-latest
    env:
      LC_ALL: C

    steps:
      - name: Set up FFmpeg
        uses: FedericoCarboni/setup-ffmpeg@v2
        with:
          version: latest

      - name: Install jq and curl
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Capture payload safely
        shell: bash
        run: |
          set -euo pipefail
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          echo "Captured payload:"
          cat payload.json

      - name: Read and validate params
        id: params
        shell: bash
        run: |
          set -euo pipefail

          RAW_AUDIO_URL=$(jq -r 'try .audio_url // ""' payload.json)
          OUT_NAME=$(jq -r 'try .out_name // "reel.mp4"' payload.json)
          WIDTH=$(jq -r 'try .width // 1080' payload.json)
          HEIGHT=$(jq -r 'try .height // 1920' payload.json)
          FPS=$(jq -r 'try .fps // 30' payload.json)
          CHUNK_SEC=$(jq -r 'try .chunk_sec // 4' payload.json)
          MAX_CLIPS=$(jq -r 'try .max_clips // 100' payload.json)
          LAYOUT_TYPE=$(jq -r 'try .layout_config.type // "single"' payload.json)

          # Push the talking-head framing DOWN by effectively "zooming in" a bit then cropping.
          # This avoids black bars and avoids the blurry rectangle you saw.
          # Increase to push the head further down.
          BOTTOM_SHIFT_PX=$(jq -r 'try .layout_config.bottom_shift_px // 260' payload.json)

          # Slow the bottom video slightly (0.90 = 10% slower). Audio remains unchanged.
          BOTTOM_SPEED=$(jq -r 'try .layout_config.bottom_speed // 0.92' payload.json)

          if [ "$RAW_AUDIO_URL" = "null" ]; then RAW_AUDIO_URL=""; fi

          if [ -z "$RAW_AUDIO_URL" ] || ! echo "$RAW_AUDIO_URL" | grep -Eiq '^https?://'; then
            echo "Error: client_payload.audio_url is missing or invalid"
            cat payload.json
            exit 1
          fi

          jq -r '
            if (.script_lines | type == "array") then
              .script_lines | map(tostring) | join("\n")
            elif (.script_text | type == "string") then
              .script_text
            else
              ""
            end
          ' payload.json > script.txt

          echo "AUDIO_URL=$RAW_AUDIO_URL" >> $GITHUB_ENV
          echo "OUT_NAME=$OUT_NAME" >> $GITHUB_ENV
          echo "WIDTH=$WIDTH" >> $GITHUB_ENV
          echo "HEIGHT=$HEIGHT" >> $GITHUB_ENV
          echo "FPS=$FPS" >> $GITHUB_ENV
          echo "CHUNK_SEC=$CHUNK_SEC" >> $GITHUB_ENV
          echo "MAX_CLIPS=$MAX_CLIPS" >> $GITHUB_ENV
          echo "LAYOUT_TYPE=$LAYOUT_TYPE" >> $GITHUB_ENV
          echo "BOTTOM_SHIFT_PX=$BOTTOM_SHIFT_PX" >> $GITHUB_ENV
          echo "BOTTOM_SPEED=$BOTTOM_SPEED" >> $GITHUB_ENV
          echo "Params: $OUT_NAME ${WIDTH}x${HEIGHT} ${FPS}fps chunk=${CHUNK_SEC}s layout=$LAYOUT_TYPE bottom_shift_px=$BOTTOM_SHIFT_PX bottom_speed=$BOTTOM_SPEED"

      - name: Validate video URLs list
        shell: bash
        run: |
          set -euo pipefail
          if [ "$LAYOUT_TYPE" = "split_screen" ]; then
            TOP_COUNT=$(jq -r 'try (.layout_config.top_videos | length) // 0' payload.json)
            BOTTOM_URL=$(jq -r 'try .layout_config.bottom_video // ""' payload.json)
            if [ "$TOP_COUNT" -lt 1 ] || [ -z "$BOTTOM_URL" ]; then
              echo "Error: split_screen requires top_videos and bottom_video"
              cat payload.json
              exit 1
            fi
            echo "Split screen: $TOP_COUNT top videos + 1 bottom video"
          else
            COUNT=$(jq -r 'try (.video_urls | length) // 0' payload.json)
            if [ "$COUNT" -lt 1 ]; then
              echo "Error: client_payload.video_urls is empty"
              cat payload.json
              exit 1
            fi
            echo "Video URL count in payload: $COUNT"
          fi

      - name: Download audio
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"
          echo "Audio URL starts with: ${AUDIO_URL:0:70}..."
          curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$AUDIO_URL" -o audio.bin
          ffmpeg -y -i audio.bin -c:a aac -b:a 192k -movflags +faststart audio.m4a

      - name: Get audio duration (float)
        id: dur
        shell: bash
        run: |
          set -euo pipefail
          DUR=$(ffprobe -v error -select_streams a:0 -show_entries stream=duration -of default=nokey=1:noprint_wrappers=1 audio.m4a || echo "")
          if [ -z "$DUR" ] || [ "$DUR" = "N/A" ]; then
            DUR=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 audio.m4a || echo "60")
          fi
          if [ -z "$DUR" ] || [ "$DUR" = "N/A" ]; then DUR="60"; fi
          echo "dur=$DUR" >> $GITHUB_OUTPUT
          echo "Audio duration (s): $DUR"
          printf "%s" "$DUR" > audio_dur.txt

      - name: Download videos (split-screen mode)
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"

          if [ "$LAYOUT_TYPE" = "split_screen" ]; then
            echo "=== Downloading TOP (B-roll) videos ==="
            i=0
            jq -r '.layout_config.top_videos[]' payload.json | while read -r URL; do
              i=$((i+1))
              [ $i -le $MAX_CLIPS ] || break
              echo "Downloading TOP $i: $URL -> top_${i}.mp4"
              curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$URL" -o "top_${i}.mp4" || echo "WARN failed $URL"
            done

            BOTTOM_URL=$(jq -r '.layout_config.bottom_video' payload.json)
            echo "Downloading BOTTOM (talking head): $BOTTOM_URL -> bottom.mp4"
            curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$BOTTOM_URL" -o "bottom.mp4" || {
              echo "ERROR: Failed to download bottom video"
              exit 1
            }

            shopt -s nullglob
            TOP_COUNT=(top_*.mp4)
            if [ ${#TOP_COUNT[@]} -eq 0 ]; then
              echo "Warning: No top videos downloaded, using bottom video only"
            fi
          else
            echo "=== Downloading videos (single mode) ==="
            i=0
            jq -r '[.video_urls] | flatten | unique[]' payload.json | while read -r URL; do
              i=$((i+1))
              [ $i -le $MAX_CLIPS ] || break
              echo "Downloading $i: $URL -> in_${i}.mp4"
              curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$URL" -o "in_${i}.mp4" || echo "WARN failed $URL"
            done

            shopt -s nullglob
            COUNT=(in_*.mp4)
            if [ ${#COUNT[@]} -eq 0 ]; then
              echo "No videos downloaded"
              exit 1
            fi
          fi

          echo "Download complete"
          ls -lh *.mp4 2>/dev/null || true

      - name: Normalize TOP clips to 9:16, mute
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          if [ "$LAYOUT_TYPE" = "split_screen" ]; then
            TOP_HEIGHT=$((HEIGHT / 2))

            for f in top_*.mp4; do
              n=${f#top_}; n=${n%.mp4}
              echo "Normalizing TOP clip $n"
              ffmpeg -y -i "$f"                 -vf "scale=${WIDTH}:${TOP_HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${TOP_HEIGHT},setsar=1,fps=${FPS}"                 -an -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -g $((FPS*2)) "norm_top_${n}.mp4"
            done
          else
            for f in in_*.mp4; do
              n=${f#in_}; n=${n%.mp4}
              echo "Normalizing $f"
              ffmpeg -y -i "$f"                 -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS}"                 -an -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -g $((FPS*2)) "norm_${n}.mp4"
            done
          fi

      - name: Normalize BOTTOM clip (split-screen only), shift down + slow slightly (no blur box)
        shell: bash
        run: |
          set -euo pipefail

          if [ "$LAYOUT_TYPE" = "split_screen" ] && [ -f "bottom.mp4" ]; then
            BOTTOM_HEIGHT=$((HEIGHT / 2))
            SHIFT="${BOTTOM_SHIFT_PX}"
            SPEED="${BOTTOM_SPEED}"

            if [ "$SHIFT" = "null" ] || [ -z "$SHIFT" ]; then SHIFT=0; fi
            if [ "$SHIFT" -lt 0 ]; then SHIFT=0; fi
            if [ "$SHIFT" -gt 520 ]; then SHIFT=520; fi

            if [ "$SPEED" = "null" ] || [ -z "$SPEED" ]; then SPEED="1.0"; fi

            # We "zoom" by scaling to (BOTTOM_HEIGHT + SHIFT) then cropping down to BOTTOM_HEIGHT starting at y=SHIFT.
            # That moves the framing down without introducing black or blur fills.
            ZH=$((BOTTOM_HEIGHT + SHIFT))
            if [ "$ZH" -lt "$BOTTOM_HEIGHT" ]; then ZH="$BOTTOM_HEIGHT"; fi

            echo "Normalizing BOTTOM: bottom_half=${BOTTOM_HEIGHT}px, shift_down=${SHIFT}px, scaled_height=${ZH}px, speed=${SPEED}x"

            ffmpeg -y -i "bottom.mp4"               -vf "fps=${FPS},setpts=PTS/${SPEED},scale=${WIDTH}:${ZH}:force_original_aspect_ratio=increase,crop=${WIDTH}:${BOTTOM_HEIGHT}:0:${SHIFT},setsar=1"               -an -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -g $((FPS*2)) "norm_bottom.mp4"
          fi

      - name: Make fixed-length chunks (split-screen mode)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          if [ "$LAYOUT_TYPE" != "split_screen" ]; then
            exit 0
          fi

          echo "=== Creating split-screen chunks ==="

          TOP_files=(norm_top_*.mp4)
          if [ ${#TOP_files[@]} -eq 0 ]; then
            echo "Error: No norm_top_*.mp4 found"
            ls -lah
            exit 1
          fi

          if [ ! -f "norm_bottom.mp4" ]; then
            echo "Error: norm_bottom.mp4 not found"
            ls -lah
            exit 1
          fi

          TARGET="$(cat audio_dur.txt)"
          CHUNK="$CHUNK_SEC"
          TOP_HEIGHT=$((HEIGHT / 2))
          BOTTOM_HEIGHT=$((HEIGHT / 2))

          NEED=$(awk -v t="$TARGET" -v c="$CHUNK" 'BEGIN{print int(t/c + 0.999999)}')
          if [ "$NEED" -lt 1 ]; then NEED=1; fi

          echo "Creating $NEED chunks of ${CHUNK}s to cover ~${TARGET}s"

          : > top_durs.txt
          for f in "${TOP_files[@]}"; do
            d=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "$f" || echo "0")
            echo "$f $d" >> top_durs.txt
          done

          rm -f chunks.txt
          TOP_COUNT=${#TOP_files[@]}

          for ((n=0; n<NEED; n++)); do
            top_idx=$(( n % TOP_COUNT ))
            top_file="${TOP_files[$top_idx]}"

            top_dur=$(awk -v k="$top_file" '$1==k{print $2}' top_durs.txt)
            top_maxstart=$(awk -v d="$top_dur" -v c="$CHUNK" 'BEGIN{s=d-c; if(s<0)s=0; printf "%.3f", s}')

            top_group=$(( n / TOP_COUNT ))
            top_start=$(awk -v g="$top_group" -v c="$CHUNK" -v m="$top_maxstart" 'BEGIN{
              s=g*c;
              while (s>m && m>0) s-=m;
              if (s>m) s=0;
              printf "%.3f", s
            }')

            out=$(printf "chunk_%04d.mp4" "$n")

            echo "Chunk $n: TOP[$top_idx start=$top_start] + BOTTOM[loop] -> $out"

            ffmpeg -hide_banner -y               -ss "$top_start" -i "$top_file" -t "$CHUNK"               -stream_loop -1 -i "norm_bottom.mp4" -t "$CHUNK"               -filter_complex "                [0:v]scale=${WIDTH}:${TOP_HEIGHT}[top];                 [1:v]scale=${WIDTH}:${BOTTOM_HEIGHT}[bottom];                 [top][bottom]vstack=inputs=2[stacked]              "               -map "[stacked]"               -an               -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -r "$FPS"               -g $((FPS*2)) "$out"

            echo "file '$out'" >> chunks.txt
          done

          if [ ! -s chunks.txt ]; then
            echo "Error: No chunks created"
            exit 1
          fi

          echo "Created $(grep -c file chunks.txt || echo 0) chunks"
          ls -lah chunk_*.mp4 2>/dev/null || true
          head -n 20 chunks.txt || true

      - name: Make fixed-length chunks (single mode)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          if [ "$LAYOUT_TYPE" = "split_screen" ]; then
            exit 0
          fi

          files=(norm_*.mp4)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No normalized clips found"; exit 1
          fi

          TARGET="$(cat audio_dur.txt)"
          CHUNK="$CHUNK_SEC"

          NEED=$(awk -v t="$TARGET" -v c="$CHUNK" 'BEGIN{print int(t/c + 0.999999)}')
          if [ "$NEED" -lt 1 ]; then NEED=1; fi
          echo "Need $NEED chunks of $CHUNK s to cover ~${TARGET}s"

          : > durs.txt
          for f in "${files[@]}"; do
            d=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "$f" || echo "0")
            echo "$f $d" >> durs.txt
          done

          rm -f chunks.txt
          FCOUNT=${#files[@]}

          for ((n=0; n<NEED; n++)); do
            idx=$(( n % FCOUNT ))
            f="${files[$idx]}"

            fdur=$(awk -v k="$f" '$1==k{print $2}' durs.txt)
            maxstart=$(awk -v d="$fdur" -v c="$CHUNK" 'BEGIN{s=d-c; if(s<0)s=0; printf "%.3f", s}')

            group=$(( n / FCOUNT ))
            start=$(awk -v g="$group" -v c="$CHUNK" -v m="$maxstart" 'BEGIN{
              s=g*c;
              while (s>m && m>0) s-=m;
              if (s>m) s=0;
              printf "%.3f", s
            }')

            out=$(printf "chunk_%04d.mp4" "$n")
            echo "Cut $f start=$start len=$CHUNK -> $out"
            ffmpeg -y -ss "$start" -i "$f" -t "$CHUNK"               -an -c:v libx264 -preset veryfast -crf 18 -r "$FPS" -pix_fmt yuv420p -g $((FPS*2)) "$out"
            echo "file '$out'" >> chunks.txt
          done

      - name: Concat chunks
        shell: bash
        run: |
          set -euo pipefail
          ffmpeg -y -f concat -safe 0 -i chunks.txt             -c:v libx264 -pix_fmt yuv420p -r "$FPS" -movflags +faststart stack.mp4

      - name: Build TikTok / Reels style ASS transcription (chunked + word highlight), positioned 1/3 up from bottom half
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -s script.txt ]; then
            echo "No script.txt, skipping subtitles."
            : > subs.missing
            exit 0
          fi

          TOTAL_SEC="$(cat audio_dur.txt)"

          TEXT=$(sed '/^[[:space:]]*$/d' script.txt | tr '
' ' ' | sed 's/  */ /g')
          if [ -z "$TEXT" ]; then
            echo "script.txt has no content, skipping subtitles."
            : > subs.missing
            exit 0
          fi

          mapfile -t WORDS < <(echo "$TEXT" | tr ' ' '
' | sed '/^[[:space:]]*$/d')
          if [ "${#WORDS[@]}" -eq 0 ]; then
            echo "No words found, skipping subtitles."
            : > subs.missing
            exit 0
          fi

          echo "Total words: ${#WORDS[@]}"

          total_chars=0
          declare -a word_chars
          for i in "${!WORDS[@]}"; do
            c=${#WORDS[$i]}
            [ "$c" -lt 1 ] && c=1
            word_chars[$i]=$c
            total_chars=$(( total_chars + c ))
          done

          fmt_time () {
            awk -v t="$1" 'BEGIN{
              if (t<0) t=0;
              h=int(t/3600); m=int((t-h*3600)/60); s=t-h*3600-m*60;
              cs=int((s - int(s))*100);
              printf("%d:%02d:%02d.%02d", h, m, int(s), cs);
            }'
          }

          CAPTION_X=$((WIDTH / 2))
          CAPTION_Y=$(( (HEIGHT / 2) + (HEIGHT / 2) * 2 / 3 ))

          : > subs.ass
          printf '%s
'             '[Script Info]'             'ScriptType: v4.00+'             "PlayResX: ${WIDTH}"             "PlayResY: ${HEIGHT}"             'WrapStyle: 2'             'ScaledBorderAndShadow: yes'             ''             '[V4+ Styles]'             'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding'             'Style: Reels,DejaVu Sans Bold,54,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,1,0,0,0,100,100,0,0,1,6,2,5,60,60,20,1'             ''             '[Events]'             'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text' >> subs.ass

          start=0
          MIN_DURATION=0.28
          pad=0.06
          WORDS_PER_CHUNK=3

          i=0
          while [ $i -lt ${#WORDS[@]} ]; do
            chunk_end=$((i + WORDS_PER_CHUNK))
            if [ $chunk_end -gt ${#WORDS[@]} ]; then
              chunk_end=${#WORDS[@]}
            fi
            chunk_size=$((chunk_end - i))

            chunk_chars=0
            for ((j=i; j<chunk_end; j++)); do
              chunk_chars=$((chunk_chars + word_chars[j]))
            done

            chunk_duration=$(awk -v t="$TOTAL_SEC" -v c="$chunk_chars" -v sum="$total_chars" -v min="$MIN_DURATION" -v size="$chunk_size" 'BEGIN{
              d=t*(c/sum);
              if (d<(min*size)) d=min*size;
              print d;
            }')

            chunk_start_time=$start
            chunk_end_time=$(awk -v a="$start" -v d="$chunk_duration" 'BEGIN{print a+d}')

            if [ $chunk_end -ge ${#WORDS[@]} ]; then
              chunk_end_time=$(awk -v t="$TOTAL_SEC" -v p="$pad" 'BEGIN{e=t-p; if(e<0)e=0; print e}')
              ok=$(awk -v a="$start" -v e="$chunk_end_time" 'BEGIN{print (e>a)?1:0}')
              [ "$ok" -ne 1 ] && chunk_end_time=$(awk -v a="$start" 'BEGIN{print a+1.0}')
            fi

            full_text=""
            for ((k=i; k<chunk_end; k++)); do
              word="${WORDS[k]}"
              esc="${word//'{'/'\{'}"
              esc="${esc//'}'/'\}'}"
              full_text="${full_text}${esc}"
              if [ $k -lt $((chunk_end - 1)) ]; then
                full_text="${full_text} "
              fi
            done

            chunk_s_str=$(fmt_time "$chunk_start_time")
            chunk_e_str=$(fmt_time "$chunk_end_time")

            printf 'Dialogue: 0,%s,%s,Reels,,0,0,0,,{\an5\pos(%d,%d)\blur0.4\fad(80,80)}%s
'               "$chunk_s_str" "$chunk_e_str" "$CAPTION_X" "$CAPTION_Y" "$full_text" >> subs.ass

            word_start=$start
            for ((j=i; j<chunk_end; j++)); do
              word_len=${word_chars[j]}

              word_duration=$(awk -v total="$chunk_duration" -v c="$word_len" -v sum="$chunk_chars" -v min="$MIN_DURATION" 'BEGIN{
                d=total*(c/sum);
                if (d<min) d=min;
                print d;
              }')

              word_end=$(awk -v a="$word_start" -v d="$word_duration" 'BEGIN{print a+d}')
              if [ $j -eq $((chunk_end - 1)) ]; then
                word_end=$chunk_end_time
              fi

              s_str=$(fmt_time "$word_start")
              e_str=$(fmt_time "$word_end")

              text=""
              for ((k=i; k<chunk_end; k++)); do
                word="${WORDS[k]}"
                esc="${word//'{'/'\{'}"
                esc="${esc//'}'/'\}'}"

                if [ $k -eq $j ]; then
                  text="${text}{\c&H00FFFF&}${esc}{\c&H00FFFFFF&}"
                else
                  text="${text}{\alpha&HFF&}${esc}{\alpha&H00&}"
                fi

                if [ $k -lt $((chunk_end - 1)) ]; then
                  text="${text} "
                fi
              done

              printf 'Dialogue: 1,%s,%s,Reels,,0,0,0,,{\an5\pos(%d,%d)\blur0.4\fad(80,80)}%s
'                 "$s_str" "$e_str" "$CAPTION_X" "$CAPTION_Y" "$text" >> subs.ass

              word_start=$word_end
            done

            i=$chunk_end
            start=$chunk_end_time
          done

          echo "Generated subtitles: $(wc -l < subs.ass) lines"
          ls -l subs.ass || true

      - name: Burn subtitles and mux audio
        shell: bash
        run: |
          set -euo pipefail

          FILTER_ARGS=()
          if [ -s subs.ass ]; then
            echo "Subtitles will be burned from subs.ass"
            FILTER_ARGS=(-vf "subtitles=subs.ass")
          else
            echo "No subs.ass present, rendering without subtitles."
          fi

          ffmpeg -y -stream_loop -1 -i stack.mp4 -i audio.m4a             "${FILTER_ARGS[@]}"             -map 0:v:0 -map 1:a:0             -shortest             -c:v libx264 -profile:v high -pix_fmt yuv420p -r "$FPS"             -c:a copy             -movflags +faststart "$OUT_NAME"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: reel-output
          path: ${{ env.OUT_NAME }}
          retention-days: 90
