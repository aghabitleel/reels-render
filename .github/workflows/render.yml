name: Render Reel

on:
  repository_dispatch:
    types: [render_reel]

permissions:
  contents: write

jobs:
  render:
    runs-on: ubuntu-latest
    env:
      LC_ALL: C

    steps:
      - name: Set up FFmpeg
        uses: FedericoCarboni/setup-ffmpeg@v2
        with:
          version: latest

      - name: Install jq and curl
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Capture payload safely
        shell: bash
        run: |
          set -euo pipefail
          # Safe here-doc so quotes in payload can't break the shell
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          echo "Captured payload:"
          cat payload.json

      - name: Read and validate params
        id: params
        shell: bash
        run: |
          set -euo pipefail

          RAW_AUDIO_URL=$(jq -r 'try .audio_url // ""' payload.json)
          OUT_NAME=$(jq -r 'try .out_name // "reel.mp4"' payload.json)
          WIDTH=$(jq -r 'try .width // 1080' payload.json)
          HEIGHT=$(jq -r 'try .height // 1920' payload.json)
          FPS=$(jq -r 'try .fps // 30' payload.json)
          CHUNK_SEC=$(jq -r 'try .chunk_sec // 4' payload.json)
          MAX_CLIPS=$(jq -r 'try .max_clips // 100' payload.json)

          # Normalize literal null
          if [ "$RAW_AUDIO_URL" = "null" ]; then RAW_AUDIO_URL=""; fi

          # Validate audio url
          if [ -z "$RAW_AUDIO_URL" ] || ! echo "$RAW_AUDIO_URL" | grep -Eiq '^https?://'; then
            echo "Error: client_payload.audio_url is missing or invalid"
            cat payload.json
            exit 1
          fi

          # Write optional script to script.txt (prefer array of lines)
          jq -r '
            if (.script_lines | type == "array") then
              .script_lines | map(tostring) | join("\n")
            elif (.script_text | type == "string") then
              .script_text
            else
              ""
            end
          ' payload.json > script.txt

          echo "AUDIO_URL=$RAW_AUDIO_URL" >> $GITHUB_ENV
          echo "OUT_NAME=$OUT_NAME" >> $GITHUB_ENV
          echo "WIDTH=$WIDTH" >> $GITHUB_ENV
          echo "HEIGHT=$HEIGHT" >> $GITHUB_ENV
          echo "FPS=$FPS" >> $GITHUB_ENV
          echo "CHUNK_SEC=$CHUNK_SEC" >> $GITHUB_ENV
          echo "MAX_CLIPS=$MAX_CLIPS" >> $GITHUB_ENV
          echo "Params: $OUT_NAME ${WIDTH}x${HEIGHT} ${FPS}fps chunk=${CHUNK_SEC}s max_clips=$MAX_CLIPS"

      - name: Validate video URLs list
        shell: bash
        run: |
          set -euo pipefail
          COUNT=$(jq -r 'try (.video_urls | length) // 0' payload.json)
          if [ "$COUNT" -lt 1 ]; then
            echo "Error: client_payload.video_urls is empty"
            cat payload.json
            exit 1
          fi
          echo "Video URL count in payload: $COUNT"

      - name: Download audio
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"
          echo "Audio URL starts with: ${AUDIO_URL:0:70}..."
          curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$AUDIO_URL" -o audio.bin
          # Normalize to AAC-in-MP4 for reliable probing and muxing
          ffmpeg -y -i audio.bin -c:a aac -b:a 192k -movflags +faststart audio.m4a

      - name: Get audio duration (float)
        id: dur
        shell: bash
        run: |
          set -euo pipefail
          DUR=$(ffprobe -v error -select_streams a:0 -show_entries stream=duration -of default=nokey=1:noprint_wrappers=1 audio.m4a || echo "")
          if [ -z "$DUR" ] || [ "$DUR" = "N/A" ]; then
            DUR=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 audio.m4a || echo "60")
          fi
          if [ -z "$DUR" ] || [ "$DUR" = "N/A" ]; then DUR="60"; fi
          echo "dur=$DUR" >> $GITHUB_OUTPUT
          echo "Audio duration (s): $DUR"
          printf "%s" "$DUR" > audio_dur.txt

      - name: Download videos
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"
          i=0
          # Flatten nested arrays and dedupe
          jq -r '[.video_urls] | flatten | unique[]' payload.json | while read -r URL; do
            i=$((i+1))
            [ $i -le $MAX_CLIPS ] || break
            echo "Downloading $URL -> in_${i}.mp4"
            curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$URL" -o "in_${i}.mp4" || echo "WARN failed $URL"
          done
          shopt -s nullglob
          COUNT=(in_*.mp4)
          if [ ${#COUNT[@]} -eq 0 ]; then
            echo "No videos downloaded"
            exit 1
          fi
          echo "Downloaded ${#COUNT[@]} inputs:"
          ls -l in_*.mp4

      - name: Normalize each clip to 9:16, mute
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          for f in in_*.mp4; do
            n=${f#in_}; n=${n%.mp4}
            echo "Normalizing $f"
            ffmpeg -y -i "$f" \
              -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS}" \
              -an -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -g $((FPS*2)) "norm_${n}.mp4"
          done

      - name: Make fixed-length chunks
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(norm_*.mp4)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No normalized clips found"; exit 1
          fi

          TARGET="$(cat audio_dur.txt)"    # float seconds
          CHUNK="$CHUNK_SEC"

          # ceil(TARGET / CHUNK) on floats via awk
          NEED=$(awk -v t="$TARGET" -v c="$CHUNK" 'BEGIN{print int(t/c + 0.999999)}')
          if [ "$NEED" -lt 1 ]; then NEED=1; fi
          echo "Need $NEED chunks of $CHUNK s to cover ~${TARGET}s"

          # Gather per-file float durations
          : > durs.txt
          for f in "${files[@]}"; do
            d=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "$f" || echo "0")
            echo "$f $d" >> durs.txt
          done

          rm -f chunks.txt
          FCOUNT=${#files[@]}

          # Build chunks, cycle and vary start so repeats are not identical
          for ((n=0; n<NEED; n++)); do
            idx=$(( n % FCOUNT ))
            f="${files[$idx]}"

            fdur=$(awk -v k="$f" '$1==k{print $2}' durs.txt)
            maxstart=$(awk -v d="$fdur" -v c="$CHUNK" 'BEGIN{s=d-c; if(s<0)s=0; printf "%.3f", s}')

            group=$(( n / FCOUNT ))
            start=$(awk -v g="$group" -v c="$CHUNK" -v m="$maxstart" 'BEGIN{
              s=g*c;
              while (s>m && m>0) s-=m;
              if (s>m) s=0;
              printf "%.3f", s
            }')

            out=$(printf "chunk_%04d.mp4" "$n")
            echo "Cut $f start=$start len=$CHUNK -> $out"
            ffmpeg -y -ss "$start" -i "$f" -t "$CHUNK" \
              -an -c:v libx264 -preset veryfast -crf 18 -r "$FPS" -pix_fmt yuv420p -g $((FPS*2)) "$out"
            echo "file '$out'" >> chunks.txt
          done

      - name: Concat chunks
        shell: bash
        run: |
          set -euo pipefail
          ffmpeg -y -f concat -safe 0 -i chunks.txt \
            -c:v libx264 -pix_fmt yuv420p -r "$FPS" -movflags +faststart stack.mp4

      - name: Build karaoke-style sentence subtitles
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -s script.txt ]; then
            echo "No script.txt, skipping subtitles."
            : > subs.missing
            exit 0
          fi

          TOTAL_SEC="$(cat audio_dur.txt)"
          
          # Read script lines (each line is a sentence)
          mapfile -t LINES < <(sed '/^[[:space:]]*$/d' script.txt)
          
          if [ "${#LINES[@]}" -eq 0 ]; then
            echo "script.txt has no lines, skipping subtitles."
            : > subs.missing
            exit 0
          fi

          echo "Total sentences: ${#LINES[@]}"

          # Split all text into words for timing
          ALL_TEXT=$(printf '%s\n' "${LINES[@]}" | tr '\n' ' ' | sed 's/  */ /g')
          mapfile -t ALL_WORDS < <(echo "$ALL_TEXT" | tr ' ' '\n' | sed '/^[[:space:]]*$/d')
          
          if [ "${#ALL_WORDS[@]}" -eq 0 ]; then
            echo "No words found, skipping subtitles."
            : > subs.missing
            exit 0
          fi

          echo "Total words: ${#ALL_WORDS[@]}"

          # Calculate timing for each word
          total_chars=0
          declare -a word_chars
          for i in "${!ALL_WORDS[@]}"; do
            c=${#ALL_WORDS[$i]}
            [ "$c" -lt 1 ] && c=1
            word_chars[$i]=$c
            total_chars=$(( total_chars + c ))
          done

          declare -a word_start
          declare -a word_end
          
          MIN_DURATION=0.35
          current_time=0
          
          for i in "${!ALL_WORDS[@]}"; do
            word_start[$i]=$current_time
            
            dur=$(awk -v t="$TOTAL_SEC" -v c="${word_chars[$i]}" -v sum="$total_chars" -v min="$MIN_DURATION" 'BEGIN{
              d=t*(c/sum); 
              if (d<min) d=min; 
              print d;
            }')
            
            current_time=$(awk -v a="$current_time" -v d="$dur" 'BEGIN{print a+d}')
            word_end[$i]=$current_time
          done

          # Adjust last word
          if [ ${#ALL_WORDS[@]} -gt 0 ]; then
            last_idx=$(( ${#ALL_WORDS[@]} - 1 ))
            word_end[$last_idx]=$(awk -v t="$TOTAL_SEC" 'BEGIN{print t-0.05}')
          fi

          fmt_time () {
            awk -v t="$1" 'BEGIN{
              if (t<0) t=0;
              h=int(t/3600); m=int((t-h*3600)/60); s=t-h*3600-m*60;
              cs=int((s - int(s))*100);
              printf("%d:%02d:%02d.%02d", h, m, int(s), cs);
            }'
          }

          # Initialize ASS file
          : > subs.ass
          printf '%s\n' \
            '[Script Info]' \
            'ScriptType: v4.00+' \
            'PlayResX: 1080' \
            'PlayResY: 1920' \
            'WrapStyle: 2' \
            'ScaledBorderAndShadow: yes' \
            '' \
            '[V4+ Styles]' \
            'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding' \
            'Style: Default,DejaVu Sans Bold,68,&H00FFFFFF,&H00FFFFFF,&H00000000,&H96000000,1,0,0,0,100,100,0,0,1,5,3,5,50,50,150,1' \
            '' \
            '[Events]' \
            'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text' >> subs.ass

          # Process each sentence
          word_idx=0
          
          for line_idx in "${!LINES[@]}"; do
            sentence="${LINES[$line_idx]}"
            
            # Split sentence into words
            mapfile -t SENTENCE_WORDS < <(echo "$sentence" | tr ' ' '\n' | sed '/^[[:space:]]*$/d')
            
            if [ "${#SENTENCE_WORDS[@]}" -eq 0 ]; then
              continue
            fi
            
            # Get timing for this sentence (from first word to last word)
            sentence_start="${word_start[$word_idx]}"
            sentence_end_idx=$(( word_idx + ${#SENTENCE_WORDS[@]} - 1 ))
            sentence_end="${word_end[$sentence_end_idx]}"
            
            # For each word in this sentence, create a subtitle showing full sentence
            # with only the current word highlighted in yellow
            for sent_word_idx in "${!SENTENCE_WORDS[@]}"; do
              global_idx=$(( word_idx + sent_word_idx ))
              
              start_time="${word_start[$global_idx]}"
              end_time="${word_end[$global_idx]}"
              
              s_str=$(fmt_time "$start_time")
              e_str=$(fmt_time "$end_time")
              
              # Build the sentence with current word highlighted
              line=""
              for j in "${!SENTENCE_WORDS[@]}"; do
                word="${SENTENCE_WORDS[$j]}"
                
                # Escape special characters
                word="${word//'{'/'\{'}"
                word="${word//'}'/'\}'}"
                
                if [ $j -eq $sent_word_idx ]; then
                  # Current word: YELLOW with bounce animation
                  line="$line{\\c&H00FFFF&\\t(0,120,\\fscx120\\fscy120)\\t(120,240,\\fscx100\\fscy100)}$word{\\r} "
                else
                  # Other words: WHITE, no animation
                  line="$line{\\c&HFFFFFF&}$word{\\r} "
                fi
              done
              
              # Write subtitle event
              printf 'Dialogue: 0,%s,%s,Default,,0,0,0,,{\\an5\\pos(540,960)\\blur0.4\\fad(100,100)}%s\n' \
                "$s_str" "$e_str" "$line" >> subs.ass
            done
            
            # Move to next sentence
            word_idx=$(( word_idx + ${#SENTENCE_WORDS[@]} ))
          done

          echo "Generated karaoke-style subtitles: $(wc -l < subs.ass) lines"
          ls -l subs.ass || true

      - name: Burn subtitles and mux audio
        shell: bash
        run: |
          set -euo pipefail

          FILTER_ARGS=()
          if [ -s subs.ass ]; then
            echo "Subtitles will be burned from subs.ass"
            FILTER_ARGS=(-vf "subtitles=subs.ass")
          else
            echo "No subs.ass present, rendering without subtitles."
          fi

          # Loop video longer than audio, then cut exactly at audio end
          ffmpeg -y -stream_loop -1 -i stack.mp4 -i audio.m4a \
            "${FILTER_ARGS[@]}" \
            -map 0:v:0 -map 1:a:0 \
            -shortest \
            -c:v libx264 -profile:v high -pix_fmt yuv420p -r "$FPS" \
            -c:a copy \
            -movflags +faststart "$OUT_NAME"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: reel-output
          path: ${{ env.OUT_NAME }}
          retention-days: 90
